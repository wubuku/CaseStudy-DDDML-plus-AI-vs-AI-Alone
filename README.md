# Case Study: DDDML + AI vs. AI Alone

## AI Alone

Step 1, create a new mud project:

```shell
pnpm create mud@latest CaseStudy-DDDML-plus-AI-vs-AI-Alone
```

Select the `vanilla` template to create a new mud project.

Run the following command to start the dev server:

```shell
pnpm dev
```

Step 2, modify the MUD config file (data model) [`mud.config.ts`](./packages/contracts/mud.config.ts) like this:

```ts
import { defineWorld } from "@latticexyz/world";

export default defineWorld({
  namespace: "app",
  tables: {
    SkillProcess: {
      schema: {
        skillProcessIdSkillType: "uint8",
        skillProcessIdPlayerId: "uint256",
        skillProcessIdSequenceNumber: "uint8",
        itemId: "uint32",
        startedAt: "uint64",
        creationTime: "uint64",
        completed: "bool",
        endedAt: "uint64",
        batchSize: "uint32",
        existing: "bool",
      },
      key: ["skillProcessIdSkillType", "skillProcessIdPlayerId", "skillProcessIdSequenceNumber"],
    },
    SkillPrcMtrlCount: {
      schema: {
        skillProcessIdSkillType: "uint8",
        skillProcessIdPlayerId: "uint256",
        skillProcessIdSequenceNumber: "uint8",
        count: "uint64",
      },
      key: ["skillProcessIdSkillType", "skillProcessIdPlayerId", "skillProcessIdSequenceNumber"],
    },
    SkillPrcMtrl: {
      schema: {
        skillProcessIdSkillType: "uint8",
        skillProcessIdPlayerId: "uint256",
        skillProcessIdSequenceNumber: "uint8",
        productionMaterialIndex: "uint64",
        productionMaterialItemId: "uint32",
        productionMaterialQuantity: "uint32",
      },
      key: ["skillProcessIdSkillType", "skillProcessIdPlayerId", "skillProcessIdSequenceNumber", "productionMaterialIndex"],
    },
    Counter: {
      schema: {
        value: "uint32",
      },
      key: [],
    },
  },
});
```

Let's assume here that we've already designed the MUD data model as above, 
and just expect the AI to generate some code of business logic. 

We even created a MUD system file, [`SkillProcessSystem.sol`](./packages/contracts/src/systems/SkillProcessSystem.sol), copy and paste the following code:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { SkillProcess, SkillProcessData } from "../codegen/index.sol";

contract SkillProcessSystem is System {

}
```

Step 3, let's prompt the AI to generate the code for the `SkillProcessSystem.sol` file:

```
You are a senior Solidity developer. You are developing a on-chain game based on the MUD framework.

In this game, players can participate in various skill-based activities like farming, woodcutting, mining, and crafting. 
However, the number of concurrent production processes is limited. 
For instance, a player can manage up to two farming processes, one woodcutting process, one mining process, and one crafting process simultaneously. 
The SkillProcess entity is designed to manage these activities.

Please read @mud.config.ts @SkillProcess.sol then write a createSkillProcess function that creates a new and unstarted process.
```

The code generated by AI is it [here](./packages/contracts/src/systems/SkillProcessSystem.sol).

First, the generated code fails to compile:

```shell
Error: Error: 
Compiler run failed:
Error (9755): Wrong argument count for struct constructor: 10 arguments given but expected 7.
  --> src/systems/SkillProcessSystem.sol:18:46:
   |
18 |         SkillProcessData memory newProcess = SkillProcessData({
   |                                              ^ (Relevant source part starts here and spans across multiple lines).

Error running "forge build"
```

Second, its implementation of the business logic is wrong.

It imported the `Counter` table generated by default by the MUD project creation tool and used it blindly:

```solidity
// ...
import { SkillProcess, SkillProcessData, Counter } from "../codegen/index.sol";
// ...
contract SkillProcessSystem is System {
    function createSkillProcess(uint8 skillType, uint256 playerId, uint32 itemId, uint32 batchSize) public returns (uint8) {
        uint32 currentSequence = Counter.get();
        Counter.set(currentSequence + 1);

        // Ensure the sequence number is within uint8 range
        require(currentSequence < 256, "Sequence number overflow");
        uint8 sequenceNumber = uint8(currentSequence);
        // ...
    }
}
```

### DDDML + AI

In the case where we applied DSL, AI generated compilable and logically correct code the first try:

https://github.com/wubuku/Dapp-LCDP-Demo/blob/main/docs/IntroToDDDMLforMudDevelopers.md#example-from-the-game-infinite-seas

In the MUD config (which was generated from DDDML model) we used for our experiments, 
the same `Counter` table and more interfering tables exist. See:
https://github.com/wubuku/hello-mud/blob/main/packages/contracts/mud.config.ts




